# B+树与Innodb 以及索引

---
[参考1-Innodb的大小计算](https://www.cnblogs.com/leefreeman/p/8315844.html)
[参考2-mysql-page大小](https://zhuanlan.zhihu.com/p/334684710)
[参考3-InnoDB的数据结构-数据页组织](https://segmentfault.com/a/1190000019321380)

[参考4-B+树索引](https://www.cnblogs.com/GrimMjx/p/10540263.html)
[参考5-辅助索引与主键索引](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
[参考6-复合/联合索引](https://www.jianshu.com/p/35588ecf33c1)

Innodb支持以下索引：
    
    B+树索引、全文索引、哈希索引

    哈希索引是自适应的，也就是说这个不是人为干预在一张表生成哈希索引，Innodb会根据这张表的是使用情况来自动生成
    
    全文索引是将存在数据库的整本书的任意内容的信息查找出来的技术，从1.2.x版本支持，每张表只能有一个全文检索的索引
    
    B+树索引是传统意义上的索引，B+树索引并不能根据键值找到具体的行数据，B+树索引只能找到行数据锁在的页，然后通过把页读到内存，
    再在内存中查找到行数据。B+树索引也是最常用的最为频繁使用的索引。

1、什么是B+树

    是一种平衡查找树，因为普通的二叉树可能因为插入的数据最后变成一个很长的链表，怎么能提高搜索的速度呢？（变成平衡书，提高查找性能）

    1、有n个子树的中间节点包含n个元素，每个元素不保存数据，只用来索引，所有的数据都保存在叶子结点
    2、所有的叶子节点包含元素的信息以及指向记录的指针，且叶子节点按关键字自小到大顺序链接
    3、所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小元素）。

    所有的数据都在叶子节点上，且每一个叶子节点都有一个只想下一个叶子节点的指针，行程了一个有序的链表。
    Q：为什要有序？其实是为了范围查找。

    优势：单一节点存储更多元素，减少IO；所有查询都要找到叶子节点，查询稳定；所有叶子节点形成有序链表，方便范围查找；

2、聚集索引和辅助索引

    聚集索引：是按照表的的主键构造的B+树，叶子节点存放的为整张表的行记录数据，每张表只能有一个聚集索引，优化器更倾向于采用聚集索引，
    直接可以获取行数据。
    
    对于每个叶子节点，都存有完整的行记录，对于主键查找速度相当的块

    辅助索引：辅助索引也叫非聚集索引，叶子节点除了键值以外还包含了一个bookmark，用来告诉InnoDB在哪里可以找到对应的行数据，
    InnoDB的辅助索引的bookmark就是相对应行数据的聚集索引键。也就是先获取指向主键索引的主键，然后通过主键索引来找到一个完整的行。
    如果辅助索引的树和聚集索引的树的高度都是3，如果不是走主键索引走辅助索引的话，那么需要6次逻辑IO访问得到最终的数据页。
    （先通过辅助索引的值（value就是对应的主键大小）找到主键索引，然后通过主键索引IO几次找到数据）

3、Innodb结构
![](https://pic4.zhimg.com/80/v2-6767156c7593255a2680840d3ec08ffb_720w.jpg)

    Linux：文件系统：
![](https://images2017.cnblogs.com/blog/352511/201801/352511-20180119104942115-967540552.png)
    
    操作系统是通过页表机制来实现进程的虚拟地址到物理地址的转化的，其中每一页的大小是固定的，为4k，一个扇区为512字节，一页为8个扇区

    InnoDB逻辑存储单元主要分为表空间、段、区、页。
    tablespace-》segment-》extent-》page。一个extent包含64个page

    假设一行数据的大小是1k，那么一个页可以存储16行数据。
    通过使用B+树的方式来组织这些数据，一个页大小为16k，约等于16384字节，每一个索引（本身类型+指针大小）大概有14字节，
    一页数据可以存放16384/14=1170个数据，高度为2的B+树，能存放1170*16=18720条数据记录，高度为3的B+树，能存放1170*1170*16
    =21902400条数据，已经是千万级别的数据存储，所以一般来说高度3就够用了。

    
4、Innodb数据页是如何组织的？
    
    数据库数据是存在磁盘中的，不过真正处理数据是在内存中进行的，这就需要从磁盘上不断地把数据读到内存中，由于内存和磁盘速度差
    几个数量级级别，所以为了避免频繁的数据交互带来的问题，mysql一次会多读取一些，是多少呢？
    读一页。一页有16kb，（这里就是按照Innodb的文件组织形式规定的大小，为16k）也就是说一次读取一般都是16kb的倍数。
    `页是磁盘内存交互的基本单位`

    一条记录称为：数据行。Innodb中有四种不同类型的数据行，Compact、Redundant、Dynamic、Compressed
    
![](https://img-blog.csdnimg.cn/20190528203300922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5MDA2MjIz,size_16,color_FFFFFF,t_70)

    一张数据页内部结构，一个16kb的页，内部放着很多行，比如3条记录，除此之外，内部存放着两个特殊的记录，最大记录和最小记录
    
    数据页内部记录是以单链表的形式存放的，头围分别是那两个特殊的记录，在内存中有很多页，页和页之间是用双链表连接的
5、B+索引扩充：

![](https://img-blog.csdnimg.cn/20190528204709166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5MDA2MjIz,size_16,color_FFFFFF,t_70)
        
    一般为了检索的快一点，我们主键都是自动生成的，所以最下面那层是根据id排序生成的，最下面那层的叶子节点是真实的数据。
    有4页，每页里面有一个单链表，就是我们的真实数据行。第二行有两页，每页中也是有个数据行构成的单链表，这是的数据行只
    包含了页码（最底下那层某页）、某页最大id，由此可见，第二行比最底下那行页数少了很多很多。就这样，一层一层的抽取，一
    定会有一个所谓的跟页。我们搜索数据就是从跟页开始的，一层一层往下找的。由于一个数据页可以存放16KB数据，所以三四层的
    树状图就已经能存放很多很多数据了，所以不要担心树会很深。再强调一下，页内是单链表，同层的页和页之间是双链表。