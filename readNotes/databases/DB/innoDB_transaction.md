# InnoDB-transaction

---

1、事务：

    读未提交、读已提交、可重复读、可串行化。

    带来的问题：
        脏读：一个事务读取到在另一个事务还未提交时的修改。
        不可重复读：一个事务在另一个事务提交前后读取到了不同数据。（侧重于某一条数据，这条数据内容发生了变化）。
        幻读：一个事务在另一个事务提交前后读取到了不同数据。（侧重于多了或是少了一条数据）。

    在 Mysql 中，默认隔离级别是可重复读，在默认时却一定程度上解决了幻读

2、Mysql中的锁：

    对于存储引擎 MyISAM ，只支持表级锁，对于 InnoDB 来说，既支持表级锁、也支持行级锁。所以 InnoDB 可以用于高并发的场景下而 MyISAM 不行。
    
    按照粒度划分：

    1、行级锁
        只对一行数据加锁，当一个事务操作某一行事务时，只对该行数据加排他锁时，其他事务对其他行数据操作时不会影响，并发性好。缺点是在加多条数据
        时加锁会比较耗时。一个事务获取到锁后直到事务提交才会释放锁。
        
        使用的场景：可串行化隔离级别

    2、表级别：
        包含两种。
        1、MDL，是 DDL 操作与 DML、DQL 操作冲突的加锁。
        2、对整张表进行加读写锁，仅针对 DML、DQL 操作。加锁快但是可承受的并发量低。　　　　　　　
            加读锁：lock table 表名  read ;  　　　　　　  
            加写锁：lock  tables  表名  write ;    　　　　　
            释放读写锁：unlock  tables;

    3、全局锁：
        对所有表所有数据进行加锁。这个锁是读锁，也就是加锁后当前数据库只能处理读操作，不能处理写操作。一般在将整个库的数据进行逻辑备份时使用（
        在 InnoDB 中可以使用 mysqldump 进行非阻塞式备份，原理就是通过 隔离级别MVCC数据一致性实现的）。
            加锁： Flush tables with read lock (FTWRL)

    4、页级锁：（存储引擎BDB，不常使用）
        对一页数据进行加锁，介于行级锁与表级锁之间

    按种类划分：

    1、共享锁（读锁）
        共享锁是对于MySQL中的读操作的，所以共享锁也叫读锁，一个事务进行读操作时，会对读取的数据添加读锁（可串行化下的读操作是自动加锁的，其他
        隔离级别需要在查询语句后面添加 lock in share mode），加锁后其他事务也可以对加锁的数据进行读取。获取了某记录的共享锁后只能对其进行
        读取，不能修改，也不能去读取其他表的数据
    
    
    
    2、排他锁（写锁）
        排它锁是对于 MySQL 中的写操作的，所以排它锁也叫写锁。添加排它锁的数据其他事务就不能进行操作，同时共享锁与排它锁也是互斥的，也就是一个
        事务对某数据添加了共享锁，那么其他事务就不能对其再添加排它锁。在所有隔离级别级别中的修改操作（insert、update、delete）都会添加排他
        锁，而读操作可以通过在语句后面添加 for update 来对读取的数据添加排它锁。

    other；

3、四种隔离级别的实现

    快照读：Mysql 默认的隔离级别是“可重复读”。通过文章开头的例子可以看出左边事务在右边事务执行修改提交前后查询的数据都一样，左边事务的查询就是
    一个快照读。快照读的数据可以看作一个快照，其他事务的修改不会改变这个快照值。也就是说快照读的数据不一定是最新值，可重复读级别也因此才保证了 
    “可重复读”。快照读的优势是不用加锁，并发效率高。

    使用场景：在 Mysql 的隔离级别中，除了可串行化级别的读外，其他隔离级别中事务的读都是快照读。

    当前读：当前读指的就是读的是最新值。既然是要求是最新值，那么就需要进行加锁限制，所以当前读是需要加锁的，同时因为当前读一定是最新的数据，所以
    就无法保证 “可重复读”。

    使用场景：首先是可串行化中事务的读操作是当前读，而四种隔离级别中的所有修改（insert、update、delete）操作都属于当前读。可能你觉得读操作和
    修改操作没有关系，但是事实是这些修改操作是先 “读” 找到数据具体的位置才能进行 “修改”

    !!!读已提交和可重复读的实现：：：MVCC机制

    MVCC机制也叫多版本并发控制，用于控制数据库的并发访问。在 Mysql 的 InnoDB 存储引擎中主要作用于实现读已提交和可重复读隔离级别。实现原理是
    通过 undo日志版本链和 Read View 。

    1、undo日志版本链。在 InnoDB 聚簇索引记录的行数据中有两个隐藏列，trx_id 和 roll_pointer，trx_id 表示当前行数据上次被修改的事务 id 
    （事务 ID 是自增的，越新的事务 ID 越大），roll_pointer 是每次在修改完数据前，都会将修改前的数据存入undo log（专门用于记录事务修改前数
    据的日志系统，用于进行事务的回滚和生成数据快照），roll_pointer 就是当前行数据修改前在 undo 日志中的存储位置。

    2、Read View。内部主要有四个部分组成，第一个是创建当前 Read View 的事务 id creator_trx_id，第二个是创建 Read View 时还未提交的事
    务 id 集合trx_ids，第三个是未提交事务 id 集合中的最大值up_limit_id，第四个是未提交事务 id 集合中的最小值low_limit_id。
    
    当执行查询操作时会先找磁盘上的数据，然后根据 Read View 里的各个值进行判断，

    1）如果该数据的 trx_id 等于 creator_trx_id，那么就说明这条数据是创建 Read View的事务修改的，那么就直接返回；
    
    2）如果 trx_id 大于等于 up_limit_id，说明是新事务修改的，那么会根据 roll_pointer 找到上一个版本的数据重新比较；
    
    3）如果 trx_id 小于 low_limit_id，那么说明是之前的事务修改的数据，那么就直接返回；
    
    4）如果 trx_id 是在 low_limit_id 与 up_limit_id 中间，那么需要去 trx_ids 中对各个元素逐个判断，如果存在相同值的元素，就根据 
    roll_pointer 找到上一个版本的数据，然后再重复判断；如果不存在就说明该数据是创建当前 Read View 时就已经修改好的了，可以返回。
    

    【没看明白】：

    而读已提交和可重复读之所以不同就是它们 Read View 生成机制不同，读已提交是每次 select 都会重新生成一次，而可重复读是一次事务只会创建
    一次且在第一次查询时创建 Read View。事务启动命令begin/start transaction不会创建Read View，但是通过 start transaction with
    consistent snapshot 开启事务就会在开始时就创建一次 Read View。

    举个网上的例子，启动事务的方式是通过 start transaction with consistent 。首先创建事务1，假设此时事务1 id 是60，事务1先修改 name 
    为小明1，那么就会在修改前将之前的记录写入 undo log，同时在修改时将生成的undo log 行数据地址写入 roll_pointer，然后暂不提交事务1。开
    一个事务2，事务 id 为 65，进行查询操作，此时生成的 Read View 的trx_ids是[60]，creator_trx_id 为 65，对应的数据状态就是下图，首先
    先得到磁盘数据的 trx_id ，为60，然后判断，不等于 creator_trx_id，然后检查，最大值和最小值都是 60，也就是属于上面 2）的情况，所以通过
    roll_pointer 从 undo log 中找到 “小明” 那条数据，再次判断，发现 50 是小于 60的，满足上面 3）的情况，所以返回数据。

![](https://img2020.cnblogs.com/blog/2012006/202011/2012006-20201127094008651-621139806.png)

    然后提交事务1，再开一个事务3，将name改成小明2，假设此时的事务3 id 是100，那么在修改前又会将 trx_id 为 60 拷贝进 undo log，同时修改
    时将 trx_id 改为100，然后事务3暂不提交，此时事务1再进行select。如果隔离级别是读已提交，那么就会重新生成 Read View，trx_ids是[100]，
    creator_trx_id 为65，判断过程和上面相似，最终返回的是小明1那条数据；而如果是可重复读，那么还是一开始的 Read View，trx_ids 还是[60]，
    creator_trx_id 还是 65，那么还是从小明2 的 trx_id 进行判断，发现不等于 65，且大于60，为情况 2），跳到 小明1 ，对 trx_id判断，还是
    大于，还是情况 2），跳转到 “小明” 那条数据，判断 trx_id <  low_mimit_id，为情况 3），所以返回 "小明"。下面是这个例子最终的示意图


![](https://img2020.cnblogs.com/blog/2012006/202011/2012006-20201126220244050-953983352.png)


    !!!读未提交和可串行化实现
    这两个实现比较简单。读未提交就是每次事务执行的修改都更新到对应的数据上，然后读取直接读取这个数据就可以了。而可串行化则是使用了读锁和写锁以
    及间隙锁来实现的，对会造成“幻读”、“脏读”、“不可重复读” 的操作会进行阻塞，也正因为这样，极易任意造成阻塞，所以不建议使用可串行化级别。
    



---未完待续-2021.07.21